#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime);
use Getopt::Std;
use File::Copy;
use Config::Simple;

###
# if @ARGV is empty, show usage and quit
if ($#ARGV < 0) {
	print "usage: $0 [-h] || [-v]\n";
	print "\tor\n";
	print "usage: $0 -t [template] -c [count] -n [name] -l [logfile]\n";
	exit(0);
}

# grab switches
our($opt_h, $opt_v, $opt_C, $opt_t, $opt_c, $opt_n, $opt_l);
getopts('hvCt:c:n:l:');

# set defaults and read values
# - may be null at this point
#
# import config
my %Config;
Config::Simple->import_from('xenbuilder.conf', \%Config) or die "Unable to read config file xenbuilder.conf.\n";

#
my $basePath=$Config{'basePath'};
my $templatePath="$basePath/$Config{'templatePath'}";
my $vmVG=$Config{'sourceVG'};
my $vmLV=$Config{'sourceLV'};
my $templateLVPath="/dev/$vmVG";
my $vmPath="$basePath/$Config{'domainPath'}";
my $vmImagePath="$basePath/$Config{'imagePath'}";
my $logPath="$basePath/$Config{'logPath'}";
my $logFile = $opt_l;
my $log; # this will hold the log file descriptor
my $template = $opt_t;
my $vmName = $opt_n;
my $count = $opt_c;

#my $file;
#my @files;

my $time = strftime "%Y%m%d-%H%M%S", localtime;

###
# defining subroutines
###

sub main {
	initValues();
	doLog();
	builder();
	closeLog();
	exit(0);
}

sub showConfig {
	# print all built-in variables
	# print all modified variables
	# note: do useful existence/perm checks at some point you lazy git
	print "VM (Image) path is $vmImagePath\n";
	if (!-e $vmImagePath) { print "\tError! $vmImagePath does not exist!\n"; }
	print "template config path is $templatePath\n";
	if (!-e $templatePath) { print "\tError! $templatePath does not exist!\n"; }
	print "VM (Domain) config path is $vmPath\n";
	if (!-e $vmPath) { print "\tError! $vmPath does not exist!\n"; }
	print "logfile path is $logPath\n";
	if (!-e $logPath) { print "\tError! $logPath does not exist!\n"; }
	return;
}

sub listTemplates {
	# open template path
	# find all files called *.cfg and push onto array
	# sort according to name
	# list array
	my $file;
	my @files;
	print "showing list of templates:\n\n";
	opendir (DIR, $templatePath) or die "Error opening $templatePath, $!\n";
	while ($file = readdir(DIR)) {
		#next if ($file =~ m/^\./);
		if ($file =~ m/^(\S+)\.cfg$/) {
			push (@files, $1) ; #no whitespace, only push if called *.cfg
		}
	}
	@files = sort {lc($a) cmp lc($b)} @files;
	foreach $file (@files) {
	    print "$file\n";
	}
	print "\n"; # ending blank line, just looks nice.
	return;
}

sub buildCommand {
#	get options
	print $log "template $template is $templatePath/$template.cfg\n";
	print $log "logfile is $logPath/$logFile\n";
	print $log "VM's are named $vmName\[1 to $count\]\n"; #fix me: grab min/max for this
	print $log "count is $count\n";
#	show command
#	print "command is:\n\t$0 -t $templatePath/$template -l $logPath/$logFile -n $vmName -c $count\n\n";
	print $log "command is:\n\t$0 -t $templatePath/$template -l $logPath/$logFile -n $vmName -c $count\n";
	return;
}

sub doLog {
	print "Opening logfile $logPath/$logFile\n";
	open ($log, ">", "$logPath/$logFile") or die "cannot open > $logPath/$logFile: $!";
	return;
}

sub closeLog {
	print "Closing logfile $logPath/$logFile\n";
	close ($log) or warn "cannot close $logPath/$logFile: $!";
	return;
}

sub initValues {
	# set $vmName to $template if undefined
	if (!defined $opt_n) {
		$vmName = $template;
	}

	# set $count to 1 if undefined
	if (!defined $opt_c) {
		$count = 1;
	}

	if (!defined $opt_l) {
		$logFile = "$vmName.$time.log";
	}
	return;
}

sub getMaxVmId {
	# open template dir
	opendir(DIR, $vmPath) or die "can't open dir $vmPath: $!";
	# read files in template path
		my @files = readdir(DIR);
	# check for pre-existing template+digit
	# find max digit
		my $maxId = 0;
		foreach my $file (@files) {
#			my ($max) = $_ =~ m/$vmName-(\d+)/;
#			$maxId = $max if $max > $maxId;
			if ($file =~ m/$vmName-\d+/) {
				my ($max) = ($file =~ m/$vmName-(\d+)/);
#				print "maxid is $maxId, max is $max, file is $file\n\n";
				$maxId = $max if $max > $maxId;
			}
		}
		closedir DIR;
	# increment counter to digit+1 $templatePath/$template
	return($maxId+1);
}

sub buildVm {
	my $id = $_[0]; # $_[0] is $vmId
	my $source = "$templatePath/$template.cfg";
	my $target = "$vmPath/$vmName-$id";
	print "creating VM config\n";
	my %Config;
	Config::Simple->import_from("$templatePath/$template.conf", \%Config) or die "Unable to read VM template config file $templatePath/$template.conf.\n";
	print $log "creating VM config: source is $source, target is $target.\n";
	if ( -f "$source" ) { # Check with -f only for files (no directories)
	        open my $in,  '<', $source or die "Can't read old file: $!";
	        open my $out, '>', $target or die "Can't write new file: $!";
	
	        while( <$in> ) {
	            s/\b($Config{'VMNAME'})\b/$vmName-$id/g;
	            print $out $_;
	            }
	        close $out;
		}
	else {
		print "\nunable to find $source.\n\n";
		exit 1;
		}

	print "creating logical volumes.\n";
	print $log "creating VM LV: source is $vmVG/$Config{'VMNAME'}-disk, target is $vmName-$id-disk.\n";
	if ( -e "/dev/$vmVG/$Config{'VMNAME'}-disk" ) {
	#	system "lvconvert -m1 $vmVG/VMNAME-disk --corelog --alloc anywhere";
	#	system "lvconvert --splitmirrors 1 --name $vmName-$id-disk $vmVG/VMNAME-disk";
		# being lazy(?) and barfing system to logfile.out
		system "lvcreate -L 512M -n $vmName-$id-swap $vmVG >> $logPath/$logFile.out 2>&1";
		system "mkswap -f /dev/$vmVG/$vmName-$id-swap >> $logPath/$logFile.out 2>&1";
		system "lvcreate -L 1G -s -n $vmName-$id-disk $vmVG/$Config{'VMNAME'}-disk >> $logPath/$logFile.out 2>&1";
	#	system "lvconvert -s VG00/VMNAME-disk VG00/$vmName-$id-disk";
	}
	else {
		print "error! source disk doesn't exist!\n\n";
	}
	system "xm create $target > LOGPATH 2>&1";
	return;
}

sub builder {
	print "Building $count VM's:\n";
	my $id=&getMaxVmId(); # fetch the maxId+1
	my $counter=0; # start counter from 0, this will count from 1
	while ($counter < $count) {
		my $vmId=$id+$counter;
		print "building $vmName-$vmId\n";
		print $log "building $vmName-$vmId\n";
		&buildVm($vmId);
		$counter++;
	}
	return;
}

# default actions (before calling main() )
# calls help, prints templates, or prints short help and quits

# if -h, then print long help, and quit
if ($opt_h) {
print <<END;
 This is $0

 This script will create, from a named template, the requested number of
 virtual machines.

 Switches:

   -h : print this help
   -v : show available templates

   -t [ template name ]		: mandatory, default location is $templatePath
   -c [ VM count ]		: default '1'
   -n [ name base ]		: defaults to [template name]
   -l [ /path/to/logfile ]	: full path & filename, otherwise $logPath/[logfile]

 Examples:

   \$ xenbuilder -t deb71_64 -c 50
   \$ xenbuilder -t ubnt1004_32 -c 50 -n ubuntu
   \$ xenbuilder -t cents59_64 -c 50 -n centos -l /opt/xenbuilder/log/centos.log

END
exit(0);
}

# if -v, then print list of available templates, and quit
if ($opt_v) {
	listTemplates();
	exit(0);
}

if ($opt_C) {
	showConfig();
	exit(0);
}

# if -t is not defined, tell the user to choose a template, and quit
# make sure this is the last "default"
if (!defined $opt_t) {
	print "Please choose a template VM to clone from.\n";
	listTemplates();
	exit(1);
}

###
# main program block begin
###

&main();
### END OF SCRIPT

