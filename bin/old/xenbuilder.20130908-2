#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime);
use Getopt::Long;
use File::Copy;
use Config::Simple;

# if @ARGV is empty, show usage and quit
if ($#ARGV < 0) {
	print "usage: $0 [-h] || [--help]\n";
        print "example: $0 --create -t [template] -c [count] -n [name] -l [logfile]\n";
	exit(0);
}

# import config
# done here because it should die if the conf file isn't available (so load it from cwd)
my %Config;
Config::Simple->import_from('xenbuilder.conf', \%Config) or die "Unable to read config file xenbuilder.conf.\n";

# set by %Config
my $basePath=$Config{'basePath'};
my $templatePath="$basePath/$Config{'templatePath'}";
my $vmPath="$basePath/$Config{'domainPath'}";
my $vmImagePath="$basePath/$Config{'imagePath'}";
my $logPath="$basePath/$Config{'logPath'}";
my $vmVG=$Config{'sourceVG'};
my $vmLV=$Config{'sourceLV'};

# derived from %Config
my $templateLVPath="/dev/$vmVG";

my $start='0';
my $stop='0';
my $create='0';
my $delete='0';
my $print='0';
my $verbose='0';
my $help='0';
my $logFile;
my $template;
my $count;
my $vmName;

my %opts;
GetOptions (\%opts,
  "start"        => \$start,
  "stop"         => \$stop,
  "create"       => \$create,
  "delete"       => \$delete,
  "print|p"      => \$print,
  "verbose|v"    => \$verbose,
  "help|h"       => \$help,     # flags
  "logfile|l=s"  => \$logFile,
  "template|t=s" => \$template,
  "count|c=i"    => \$count,    # number
  "name|n=s"     => \$vmName    # string
  );

my $command = $start + $stop + $create + $delete + $print + $help + $verbose;

if ($command != 1) {
  print "ERROR: Use EXACTLY ONE mandatory command.\n";
  &printLongHelp;
  exit 1;
}

# set the time for the logging
my $time = strftime "%Y%m%d-%H%M%S", localtime;

# set $vmName to $template if undefined
if (!defined $vmName) {
  if (defined $template) {
    $vmName = $template;
  }
  else {
    $vmName = "xenbuilder";
  }
}

# set $count to 1 if undefined
if (!defined $count) {
  $count = 1;
  }

if (!defined $logFile) {
  $logFile = "$vmName.$time.log";
  }

my $log; # this will hold the log file descriptor

#my $file;
#my @files;


###
# defining subroutines
###

sub main {
  if ($print) { &listTemplates(); }
  if ($verbose) { &showConfig(); }
  if ($help) { &printLongHelp(); }
  if ($start) {
    openLog();
    &doStart();
    closeLog();
  }
  if ($stop) {
    openLog();
    &doStop();
    closeLog();
  }
  if ($delete) {
    openLog();
    &doDelete();
    closeLog();
  }
  if ($create) {
    openLog();
    &builder();
    closeLog();
  }
  exit(0);
}

sub doStart {
  return;
}

sub doStop {
  return;
}

sub doDelete {
  return;
}

sub showConfig {
	# print all built-in variables
	# print all modified variables
	# note: do useful existence/perm checks at some point you lazy git
	print "VM (Image) path is $vmImagePath\n";
	if (!-e $vmImagePath) { print "\tError! $vmImagePath does not exist!\n"; }
	print "template config path is $templatePath\n";
	if (!-e $templatePath) { print "\tError! $templatePath does not exist!\n"; }
	print "VM (Domain) config path is $vmPath\n";
	if (!-e $vmPath) { print "\tError! $vmPath does not exist!\n"; }
	print "logfile path is $logPath\n";
	if (!-e $logPath) { print "\tError! $logPath does not exist!\n"; }
	return;
}

sub listTemplates {
	# open template path
	# find all files called *.cfg and push onto array
	# sort according to name
	# list array
	my $file;
	my @files;
	print "showing list of templates:\n\n";
	opendir (DIR, $templatePath) or die "Error opening $templatePath, $!\n";
	while ($file = readdir(DIR)) {
		#next if ($file =~ m/^\./);
		if ($file =~ m/^(\S+)\.cfg$/) {
			push (@files, $1) ; #no whitespace, only push if called *.cfg
		}
	}
	@files = sort {lc($a) cmp lc($b)} @files;
	foreach $file (@files) {
	    print "$file\n";
	}
	print "\n"; # ending blank line, just looks nice.
	return;
}

sub buildCommand {
#	get options
	print $log "template $template is $templatePath/$template.cfg\n";
	print $log "logfile is $logPath/$logFile\n";
	print $log "VM's are named $vmName\[1 to $count\]\n"; #fix me: grab min/max for this
	print $log "count is $count\n";
#	show command
#	print "command is:\n\t$0 -t $templatePath/$template -l $logPath/$logFile -n $vmName -c $count\n\n";
	print $log "command is:\n\t$0 -t $templatePath/$template -l $logPath/$logFile -n $vmName -c $count\n";
	return;
}

sub openLog {
	print "Opening logfile $logPath/$logFile\n";
	open ($log, ">", "$logPath/$logFile") or die "cannot open > $logPath/$logFile: $!";
	return;
}

sub closeLog {
	print "Closing logfile $logPath/$logFile\n";
	close ($log) or warn "cannot close $logPath/$logFile: $!";
	return;
}

sub getMaxVmId {
	# open template dir
	opendir(DIR, $vmPath) or die "can't open dir $vmPath: $!";
	# read files in template path
		my @files = readdir(DIR);
	# check for pre-existing template+digit
	# find max digit
		my $maxId = 0;
		foreach my $file (@files) {
			if ($file =~ m/$vmName-\d+$/) {
				my ($max) = ($file =~ m/$vmName-(\d+)$/);
				$maxId = $max if $max > $maxId;
			}
		}
		closedir DIR;
	# increment counter to digit+1 $templatePath/$template
	return($maxId+1);
}

sub buildVm {
	my $id = $_[0]; # $_[0] is $vmId
	my $source = "$templatePath/$template.cfg";
	my $target = "$vmPath/$vmName-$id.vm";
	print "creating VM config\n";
	my %Config;
	Config::Simple->import_from("$templatePath/$template.conf", \%Config) or die "Unable to read VM template config file $templatePath/$template.conf.\n";
	print $log "creating VM config: source is $source, target is $target.\n";
	if ( -f "$source" ) { # Check with -f only for files (no directories)
	        open my $in,  '<', $source or die "Can't read old file: $!";
	        open my $out, '>', $target or die "Can't write new file: $!";
	
	        while( <$in> ) {
	            s/\b($Config{'VMNAME'})\b/$vmName-$id/g;
	            print $out $_;
	            }
	        close $out;
		}
	else {
		print "\nunable to find $source.\n\n";
		exit 1;
		}

	print "creating logical volumes.\n";
	print $log "creating VM LV: source is $vmVG/$Config{'VMNAME'}-disk, target is $vmName-$id-disk.\n";
	if ( -e "/dev/$vmVG/$Config{'VMNAME'}-disk" ) {
	#	system "lvconvert -m1 $vmVG/VMNAME-disk --corelog --alloc anywhere";
	#	system "lvconvert --splitmirrors 1 --name $vmName-$id-disk $vmVG/VMNAME-disk";
		# being lazy(?) and barfing system to logfile.out
		system "lvcreate -L 512M -n $vmName-$id-swap $vmVG >> $logPath/$logFile.out 2>&1";
		system "mkswap -f /dev/$vmVG/$vmName-$id-swap >> $logPath/$logFile.out 2>&1";
		system "lvcreate -L 1G -s -n $vmName-$id-disk $vmVG/$Config{'VMNAME'}-disk >> $logPath/$logFile.out 2>&1";
	#	system "lvconvert -s VG00/VMNAME-disk VG00/$vmName-$id-disk";
	}
	else {
		print "error! source disk doesn't exist at $source!\n\n";
	}
	system "xm create $target > LOGPATH 2>&1";
	return;
}

sub builder {
  # if -t is not defined, tell the user to choose a template, and quit
  # make sure this is the last "default"
  if (!defined $template) {
    print "\n\tERROR: please choose a template with -t or --template.\n\n";
    print $log "in CREATE: template was not defined. bailing out.\n";
    &listTemplates();
    return(1);
  }

	print "Building $count VM's:\n";
	my $id=&getMaxVmId(); # fetch the maxId+1
	my $counter=0; # start counter from 0, this will count from 1
	while ($counter < $count) {
		my $vmId=$id+$counter;
		print "building $vmName-$vmId\n";
		print $log "building $vmName-$vmId\n";
		&buildVm($vmId);
		$counter++;
	}
	return;
}

# if -h, then print long help, and quit
if ($help) {
  &printLongHelp();
  exit(0);
  }

sub printLongHelp {
print <<END;
 This is $0

 This script will create, from a named template, the requested number of
 virtual machines.

 Mandatory Command Switches:
  Use EXACTLY ONE of:
   --start,--stop,--delete,--create,--print|-p,--help|-h (this file)

 Option Switches:
  Short Versions

   -t [ template name ]		: mandatory, default location is $templatePath
   -c [ VM count ]		: default '1'
   -n [ VM Name Base ]		: defaults to [ template name ]
   -l [ Logfile Name ]		: log filename, default is $logPath/$0.[current date]

  Long Versions
   --help
   --print
   --template=[ template name ]
   --count=[ VM count ]
   --name=[ VM Name Base ]
   --logfile=[ logfile name ]

 Examples:

   \$ xenbuilder --create -t deb71_64 -c 50
   \$ xenbuilder --start -c 50 -n ubuntu

END
}

###
# main program block begin
###

&main();
### END OF SCRIPT

